{"meta":{"title":"山海经","subtitle":"","description":"记录身边的贵物","author":"Liu Hao","url":"http://zutlh.top","root":"/"},"pages":[{"title":"about","date":"2022-04-21T08:18:10.000Z","updated":"2022-04-21T08:59:43.477Z","comments":true,"path":"about/index.html","permalink":"http://zutlh.top/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Optional详解","slug":"newpapername","date":"2022-04-20T02:29:34.000Z","updated":"2022-04-21T07:45:25.493Z","comments":true,"path":"2022/04/20/newpapername/","link":"","permalink":"http://zutlh.top/2022/04/20/newpapername/","excerpt":"","text":"&lt;!--more--&gt; 在文章的开头，先说下NPE问题，NPE问题就是，我们在开发中经常碰到的NullPointerException.假设我们有两个类，他们的UML类图如下图所示 在这种情况下，有如下代码 1user.getAddress().getProvince(); 这种写法，在user为null时，是有可能报NullPointerException异常的。为了解决这个问题，于是采用下面的写法 123456if(user!=null)&#123; Address address = user.getAddress(); if(address!=null)&#123; String province = address.getProvince(); &#125;&#125; 这种写法是比较丑陋的，为了避免上述丑陋的写法，让丑陋的设计变得优雅。JAVA8提供了Optional类来优化这种写法，接下来的正文部分进行详细说明 API介绍先介绍一下API，与其他文章不同的是，本文采取类比的方式来讲，同时结合源码。而不像其他文章一样，一个个API罗列出来，让人找不到重点。 1、Optional(T value),empty(),of(T value),ofNullable(T value)这四个函数之间具有相关性，因此放在一组进行记忆。 先说明一下，Optional(T value)，即构造函数，它是private权限的，不能由外部调用的。其余三个函数是public权限，供我们所调用。那么，Optional的本质，就是内部储存了一个真实的值，在构造的时候，就直接判断其值是否为空。好吧，这么说还是比较抽象。直接上Optional(T value)构造函数的源码，如下图所示 那么，of(T value)的源码如下 123public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123; return new Optional&lt;&gt;(value);&#125; 也就是说of(T value)函数内部调用了构造函数。根据构造函数的源码我们可以得出两个结论: 通过of(T value)函数所构造出的Optional对象，当Value值为空时，依然会报NullPointerException。 通过of(T value)函数所构造出的Optional对象，当Value值不为空时，能正常构造Optional对象。 除此之外呢，Optional类内部还维护一个value为null的对象，大概就是长下面这样的 12345678910111213public final class Optional&lt;T&gt; &#123; //省略.... private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;(); private Optional() &#123; this.value = null; &#125; //省略... public static&lt;T&gt; Optional&lt;T&gt; empty() &#123; @SuppressWarnings(&quot;unchecked&quot;) Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY; return t; &#125;&#125; 那么，empty（）的作用就是返回EMPTY对象。 好了铺垫了这么多，可以说ofNullable(T value)的作用了，上源码 123public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123; return value == null ? empty() : of(value);&#125; 好吧，大家应该都看得懂什么意思了。相比较of(T value)的区别就是，当value值为null时，of(T value)会报NullPointerException异常；ofNullable(T value)不会throw Exception，ofNullable(T value)直接返回一个EMPTY对象。 那是不是意味着，我们在项目中只用ofNullable函数而不用of函数呢? 不是的，一个东西存在那么自然有存在的价值。当我们在运行过程中，不想隐藏NullPointerException。而是要立即报告，这种情况下就用Of函数。但是不得不承认，这样的场景真的很少。博主也仅在写junit测试用例中用到过此函数。 2、orElse(T other)，orElseGet(Supplier other)和orElseThrow(Supplier exceptionSupplier)这三个函数放一组进行记忆，都是在构造函数传入的value值为null时，进行调用的。orElse和orElseGet的用法如下所示，相当于value值为null时，给予一个默认值: 123456789101112@Testpublic void test() &#123; User user = null; user = Optional.ofNullable(user).orElse(createUser()); user = Optional.ofNullable(user).orElseGet(() -&gt; createUser());&#125;public User createUser()&#123; User user = new User(); user.setName(&quot;zhangsan&quot;); return user;&#125; 这两个函数的区别：当user值不为null时，orElse函数依然会执行createUser()方法，而orElseGet函数并不会执行createUser()方法，大家可自行测试。 至于orElseThrow，就是value值为null时,直接抛一个异常出去，用法如下所示 12User user = null;Optional.ofNullable(user).orElseThrow(()-&gt;new Exception(&quot;用户不存在&quot;)); 3、map(Function mapper)和flatMap(Function&gt; mapper)这两个函数放在一组记忆，这两个函数做的是转换值的操作。 直接上源码 1234567891011121314151617181920 public final class Optional&lt;T&gt; &#123; //省略.... public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else &#123; return Optional.ofNullable(mapper.apply(value)); &#125; &#125; //省略... public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else &#123; return Objects.requireNonNull(mapper.apply(value)); &#125; &#125;&#125; 这两个函数，在函数体上没什么区别。唯一区别的就是入参，map函数所接受的入参类型为Function&lt;? super T, ? extends U&gt;，而flapMap的入参类型为Function&lt;? super T, Optional&lt;U&gt;&gt;。 在具体用法上，对于map而言： 如果User结构是下面这样的 123456public class User &#123; private String name; public String getName() &#123; return name; &#125;&#125; 这时候取name的写法如下所示 1String city = Optional.ofNullable(user).map(u-&gt; u.getName()).get(); 对于flatMap而言: 如果User结构是下面这样的 123456public class User &#123; private String name; public Optional&lt;String&gt; getName() &#123; return Optional.ofNullable(name); &#125;&#125; 这时候取name的写法如下所示 1String city = Optional.ofNullable(user).flatMap(u-&gt; u.getName()).get(); 4、isPresent()和ifPresent(Consumer consumer)这两个函数放在一起记忆，isPresent即判断value值是否为空，而ifPresent就是在value值不为空时，做一些操作。这两个函数的源码如下 1234567891011public final class Optional&lt;T&gt; &#123; //省略.... public boolean isPresent() &#123; return value != null; &#125; //省略... public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123; if (value != null) consumer.accept(value); &#125;&#125; 需要额外说明的是，大家千万不要把 123if (user != null)&#123; // TODO: do something&#125; 给写成 1234User user = Optional.ofNullable(user);if (Optional.isPresent())&#123; // TODO: do something&#125; 因为这样写，代码结构依然丑陋。博主会在后面给出正确写法 至于ifPresent(Consumer&lt;? super T&gt; consumer)，用法也很简单，如下所示 123Optional.ofNullable(user).ifPresent(u-&gt;&#123; // TODO: do something&#125;); 5、filter(Predicate predicate)不多说，直接上源码 12345678public final class Optional&lt;T&gt; &#123; //省略.... Objects.requireNonNull(predicate); if (!isPresent()) return this; else return predicate.test(value) ? this : empty();&#125; filter 方法接受一个 Predicate 来对 Optional 中包含的值进行过滤，如果包含的值满足条件，那么还是返回这个 Optional；否则返回 Optional.empty。 用法如下 1Optional&lt;User&gt; user1 = Optional.ofNullable(user).filter(u -&gt; u.getName().length()&lt;6); 如上所示，如果user的name的长度是小于6的，则返回。如果是大于6的，则返回一个EMPTY对象。 实战使用例一在函数方法中 以前写法 1234567891011public String getCity(User user) throws Exception&#123; if(user!=null)&#123; if(user.getAddress()!=null)&#123; Address address = user.getAddress(); if(address.getCity()!=null)&#123; return address.getCity(); &#125; &#125; &#125; throw new Excpetion(&quot;取值错误&quot;); &#125; JAVA8写法 123456public String getCity(User user) throws Exception&#123; return Optional.ofNullable(user) .map(u-&gt; u.getAddress()) .map(a-&gt;a.getCity()) .orElseThrow(()-&gt;new Exception(&quot;取指错误&quot;));&#125; 例二比如，在主程序中 以前写法 123if(user!=null)&#123; dosomething(user);&#125; JAVA8写法 1234 Optional.ofNullable(user) .ifPresent(u-&gt;&#123; dosomething(u);&#125;); 例三以前写法 123456789101112public User getUser(User user) throws Exception&#123; if(user!=null)&#123; String name = user.getName(); if(&quot;zhangsan&quot;.equals(name))&#123; return user; &#125; &#125;else&#123; user = new User(); user.setName(&quot;zhangsan&quot;); return user; &#125;&#125; java8写法 123456789public User getUser(User user) &#123; return Optional.ofNullable(user) .filter(u-&gt;&quot;zhangsan&quot;.equals(u.getName())) .orElseGet(()-&gt; &#123; User user1 = new User(); user1.setName(&quot;zhangsan&quot;); return user1; &#125;);&#125; 其他的例子，不一一列举了。不过采用这种链式编程，虽然代码优雅了。但是，逻辑性没那么明显，可读性有所降低，大家项目中看情况酌情使用。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zutlh.top/tags/Java/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zutlh.top/tags/Java/"}]}